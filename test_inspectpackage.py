# Test cases automatically generated by Pynguin (https://github.com/se2p/pynguin).
# Please check them before you use them.
import pytest
import inspectpackage as module_0
import py2puml.domain.umlrelation as module_1
import py2puml.inspection.inspectmodule as module_2
import pkgutil as module_3
import py2puml.domain.umlitem as module_4


@pytest.mark.xfail(strict=True)
def test_case_0():
    list_0 = []
    str_0 = '\nk[0#"NgDa\x0cx7<'
    str_1 = '4cTO+z"n]rI7p'
    var_0 = module_0.inspect_package(str_0, str_1, str_0, str_1)
    module_0.inspect_package(var_0, list_0, var_0, var_0)


@pytest.mark.xfail(strict=True)
def test_case_1():
    str_0 = "f@Xv!qO*X"
    str_1 = ", expected_line="
    var_0 = module_0.inspect_package(str_0, str_1, str_1, str_0)
    none_type_0 = None
    str_2 = "["
    dict_0 = {str_2: none_type_0, str_2: none_type_0}
    var_1 = module_0.inspect_package(str_2, none_type_0, none_type_0, dict_0)
    str_3 = 'D(KJ"tw<K/P7XW|xq'
    module_0.inspect_package(none_type_0, str_3, var_1, var_1)


@pytest.mark.xfail(strict=True)
def test_case_2():
    str_0 = "]V;$ 2'DUX5O91"
    bool_0 = False
    uml_relation_0 = module_1.UmlRelation(str_0, str_0, bool_0)
    str_1 = "jL;"
    var_0 = module_2.inspect_module(uml_relation_0, str_1, str_0, str_1)
    str_2 = "py2puml.domain"
    uml_relation_1 = module_1.UmlRelation(str_2, var_0, var_0)
    module_0.inspect_package(var_0, str_0, uml_relation_1, str_1)


@pytest.mark.xfail(strict=True)
def test_case_3():
    bool_0 = False
    module_0.inspect_package(bool_0, bool_0, bool_0, bool_0)


@pytest.mark.xfail(strict=True)
def test_case_4():
    set_0 = set()
    str_0 = "!D"
    var_0 = module_3.walk_packages()
    var_1 = var_0.__repr__()
    var_2 = var_1.__repr__()
    var_3 = var_2.__eq__(str_0)
    list_0 = [var_3]
    module_0.inspect_package(set_0, str_0, str_0, list_0)


def test_case_5():
    pass


@pytest.mark.xfail(strict=True)
def test_case_6():
    str_0 = "f^*bRR/6(k\tzl'f\"P"
    str_1 = "PlEZWu~g~&E"
    var_0 = module_0.inspect_package(str_0, str_1, str_0, str_0)
    var_1 = var_0.__eq__(str_1)
    str_2 = "hzlz70/.z_H"
    none_type_0 = None
    str_3 = "a0GKb#(I-]t\tg9|OvqBU"
    module_0.inspect_package(none_type_0, str_3, str_2, var_1)


@pytest.mark.xfail(strict=True)
def test_case_7():
    bool_0 = False
    str_0 = ""
    str_1 = "s#!9b6+8n\x0bkq],m"
    none_type_0 = None
    var_0 = module_3.walk_packages(prefix=none_type_0)
    list_0 = [var_0, var_0]
    var_1 = module_2.inspect_module(bool_0, str_1, bool_0, list_0)
    list_1 = [var_1, var_1, var_1, var_1]
    module_0.inspect_package(bool_0, str_0, bool_0, list_1)


@pytest.mark.xfail(strict=True)
def test_case_8():
    str_0 = ""
    str_1 = "_fields"
    str_2 = ": it needs to be imported explicitely."
    none_type_0 = None
    var_0 = module_0.inspect_package(str_2, str_1, none_type_0, str_0)
    var_1 = var_0.__eq__(str_2)
    module_0.inspect_package(str_0, str_1, var_0, var_0)


@pytest.mark.xfail(strict=True)
def test_case_9():
    str_0 = ""
    str_1 = "\n    Given a module and a partially namespaced type name, returns a tuple of information about the type:\n    - the full-namespaced type name, to draw relationships between types without ambiguity\n    - the short type name, for display purposes\n\n    Different approaches are combined to derive the type information:\n    - when the partially namespaced type is found during AST parsing (class constructors)\n    - when the partially namespaced type is found during class inspection (dataclasses, class static variables, named tuples, enums)\n\n    The two approaches are a bit entangled for now, they could be separated a bit more for performance sake.\n    "
    bool_0 = False
    module_0.inspect_package(str_0, str_1, str_0, bool_0)


def test_case_10():
    domain_path = "path/to/domain"
    domain_module = "domain_module_name"
    domain_items_by_fqn = {"item_1": module_4.UmlItem("item_1", "Class")}
    domain_relations = [module_1.UmlRelation("item_1", "item_2", False)]
    module_0.inspect_package(domain_path, domain_module, domain_items_by_fqn, domain_relations)


def test_case_11():
    domain_path = "path/to/another/domain"
    domain_module = "another_domain_module_name"
    domain_items_by_fqn = {"item_2": module_4.UmlItem("item_2", "Class")}
    domain_relations = [module_1.UmlRelation("item_2", "item_3", True)]
    module_0.inspect_package(domain_path, domain_module, domain_items_by_fqn, domain_relations)


def test_case_12():
    domain_path = "path/to/third/domain"
    domain_module = "third_domain_module_name"
    domain_items_by_fqn = {"item_3": module_4.UmlItem("item_3", "Class")}
    domain_relations = [module_1.UmlRelation("item_3", "item_4", True)]
    module_0.inspect_package(domain_path, domain_module, domain_items_by_fqn, domain_relations)

@pytest.mark.xfail(strict=True)
def test_case_13():
    module_0.inspect_package(None, None, None, None)

def test_case_14():
    domain_path = "valid/path/to/module"
    domain_module = "valid_module"
    domain_items_by_fqn = {"item_1": module_4.UmlItem("item_1", "Class")}
    domain_relations = [module_1.UmlRelation("item_1", "item_2", False)]
    module_0.inspect_package(domain_path, domain_module, domain_items_by_fqn, domain_relations)



@pytest.mark.xfail(strict=True)
def test_case_15():
    domain_path = 123
    domain_module = 456
    domain_items_by_fqn = 789
    domain_relations = 101112
    module_0.inspect_package(domain_path, domain_module, domain_items_by_fqn, domain_relations)


@pytest.mark.xfail(strict=True)
def test_case_16():
    domain_path = "valid/path"
    domain_module = "invalid_module"
    domain_items_by_fqn = {"item_1": module_4.UmlItem("item_1", "Class", "module_1")}
    domain_relations = [module_1.UmlRelation("item_1", "item_2", False)]
    module_0.inspect_package(domain_path, domain_module, domain_items_by_fqn, domain_relations)


def test_case_17():
    domain_path = "another/valid/path"
    domain_module = "valid_module"
    domain_items_by_fqn = {"item_2": module_4.UmlItem("item_2", "Class")}
    domain_relations = [module_1.UmlRelation("item_2", "item_3", True)]
    module_0.inspect_package(domain_path, domain_module, domain_items_by_fqn, domain_relations)


def test_case_18():
    domain_path = "another/valid/path"
    domain_module = "another_valid_module"
    domain_items_by_fqn = {"item_2": module_4.UmlItem("item_2", "Class")}
    domain_relations = [module_1.UmlRelation("item_2", "item_3", True)]
    module_0.inspect_package(domain_path, domain_module, domain_items_by_fqn, domain_relations)

def test_case_19():
    domain_path = "yet/another/valid/path"
    domain_module = "yet_another_valid_module"
    domain_items_by_fqn = {"item_3": module_4.UmlItem("item_3", "Class")}
    domain_relations = [module_1.UmlRelation("item_3", "item_4", True)]
    module_0.inspect_package(domain_path, domain_module, domain_items_by_fqn, domain_relations)


def test_case_20():
    str_0 = "random_string"
    str_1 = "another_random_string"
    dict_0 = {str_0: str_1}
    list_0 = [str_0, str_1]
    module_0.inspect_package(str_0, str_1, dict_0, list_0)


def test_case_21():
    str_0 = "third_random_string"
    str_1 = "fourth_random_string"
    bool_0 = False
    uml_relation_0 = module_1.UmlRelation(str_0, str_1, bool_0)
    dict_0 = {str_0: uml_relation_0}
    list_0 = [uml_relation_0]
    module_0.inspect_package(str_0, str_1, dict_0, list_0)


def test_case_22():
    str_0 = "fifth_random_string"
    str_1 = "sixth_random_string"
    bool_0 = True
    uml_relation_0 = module_1.UmlRelation(str_1, str_0, bool_0)
    dict_0 = {str_0: uml_relation_0}
    list_0 = [str_0, str_1, uml_relation_0]
    module_0.inspect_package(str_0, str_1, dict_0, list_0)

def test_case_23():
    str_0 = "seventh_random_string"
    str_1 = "eightth_random_string"
    bool_0 = True
    uml_relation_0 = module_1.UmlRelation(str_1, str_0, bool_0)
    dict_0 = {str_0: uml_relation_0}
    list_0 = [str_0, str_1, uml_relation_0]
    module_0.inspect_package(str_0, str_1, dict_0, list_0)

@pytest.mark.xfail(strict=True)
def test_case_24():
    str_0 = "f@Xv!qO*X"
    str_1 = ", expected_line="
    var_0 = module_0.inspect_package(str_0, str_1, str_1, str_0)
    none_type_0 = None
    str_2 = "["
    dict_0 = {str_2: none_type_0, str_2: none_type_0}
    var_1 = module_0.inspect_package(str_2, none_type_0, none_type_0, dict_0)
    str_3 = 'D(KJ"tw<K/P7XW|xq'
    module_0.inspect_package(none_type_0, str_3, var_1, var_1)


@pytest.mark.xfail(strict=True)
def test_case_25():
    str_0 = "f^*bRR/6(k\tzl'f\"P"
    str_1 = "PlEZWu~g~&E"
    var_0 = module_0.inspect_package(str_0, str_1, str_0, str_0)
    var_1 = var_0.__eq__(str_1)
    str_2 = "hzlz70/.z_H"
    none_type_0 = None
    str_3 = "a0GKb#(I-]t\tg9|OvqBU"
    module_0.inspect_package(none_type_0, str_3, str_2, var_1)


@pytest.mark.xfail(strict=True)
def test_case_26():
    bool_0 = False
    str_0 = ""
    str_1 = "s#!9b6+8n\x0bkq],m"
    none_type_0 = None
    var_0 = module_3.walk_packages(prefix=none_type_0)
    list_0 = [var_0, var_0]
    var_1 = module_2.inspect_module(bool_0, str_1, bool_0, list_0)
    list_1 = [var_1, var_1, var_1, var_1]
    module_0.inspect_package(bool_0, str_0, bool_0, list_1)


@pytest.mark.xfail(strict=True)
def test_case_27():
    str_0 = ""
    str_1 = "_fields"
    str_2 = ": it needs to be imported explicitly."
    none_type_0 = None
    var_0 = module_0.inspect_package(str_2, str_1, none_type_0, str_0)
    var_1 = var_0.__eq__(str_2)
    module_0.inspect_package(str_0, str_1, var_0, var_0)


@pytest.mark.xfail(strict=True)
def test_case_28():
    str_0 = ""
    str_1 = "\n    Given a module and a partially namespaced type name, returns a tuple of information about the type:\n    - the full-namespaced type name, to draw relationships between types without ambiguity\n    - the short type name, for display purposes\n\n    Different approaches are combined to derive the type information:\n    - when the partially namespaced type is found during AST parsing (class constructors)\n    - when the partially namespaced type is found during class inspection (dataclasses, class static variables, named tuples, enums)\n\n    The two approaches are a bit entangled for now, they could be separated a bit more for performance sake.\n    "
    bool_0 = False
    module_0.inspect_package(str_0, str_1, str_0, bool_0)


@pytest.mark.xfail(strict=True)
def test_case_29():
    list_0 = []
    str_0 = '\nk[0#"NgDa\x0cx7<'
    str_1 = '4cTO+z"n]rI7p'
    var_0 = module_0.inspect_package(str_0, str_1, str_0, str_1)
    module_0.inspect_package(var_0, list_0, var_0, var_0)


@pytest.mark.xfail(strict=True)
def test_case_30():
    set_0 = set()
    str_0 = "!D"
    var_0 = module_3.walk_packages()
    var_1 = var_0.__repr__()
    var_2 = var_1.__repr__()
    var_3 = var_2.__eq__(str_0)
    list_0 = [var_3]
    module_0.inspect_package(set_0, str_0, str_0, list_0)


@pytest.mark.xfail(strict=True)
def test_case_31():
    str_0 = "f^*bRR/6(k\tzl'f\"P"
    str_1 = "PlEZWu~g~&E"
    var_0 = module_0.inspect_package(str_0, str_1, str_0, str_0)
    var_1 = var_0.__eq__(str_1)
    str_2 = "hzlz70/.z_H"
    none_type_0 = None
    str_3 = "a0GKb#(I-]t\tg9|OvqBU"
    module_0.inspect_package(none_type_0, str_3, str_2, var_1)


@pytest.mark.xfail(strict=True)
def test_case_32():
    bool_0 = False
    str_0 = ""
    str_1 = "s#!9b6+8n\x0bkq],m"
    none_type_0 = None
    var_0 = module_3.walk_packages(prefix=none_type_0)
    list_0 = [var_0, var_0]
    var_1 = module_2.inspect_module(bool_0, str_1, bool_0, list_0)
    list_1 = [var_1, var_1, var_1, var_1]
    module_0.inspect_package(bool_0, str_0, bool_0, list_1)


@pytest.mark.xfail(strict=True)
def test_case_33():
    str_0 = ""
    str_1 = "_fields"
    str_2 = ": it needs to be imported explicitly."
    none_type_0 = None
    var_0 = module_0.inspect_package(str_2, str_1, none_type_0, str_0)
    var_1 = var_0.__eq__(str_2)
    module_0.inspect_package(str_0, str_1, var_0, var_0)


@pytest.mark.xfail(strict=True)
def test_case_34():
    str_0 = ""
    str_1 = "\n    Given a module and a partially namespaced type name, returns a tuple of information about the type:\n    - the full-namespaced type name, to draw relationships between types without ambiguity\n    - the short type name, for display purposes\n\n    Different approaches are combined to derive the type information:\n    - when the partially namespaced type is found during AST parsing (class constructors)\n    - when the partially namespaced type is found during class inspection (dataclasses, class static variables, named tuples, enums)\n\n    The two approaches are a bit entangled for now, they could be separated a bit more for performance sake.\n    "
    bool_0 = False
    module_0.inspect_package(str_0, str_1, str_0, bool_0)


@pytest.mark.xfail(strict=True)
def test_case_35():
    list_0 = []
    str_0 = '\nk[0#"NgDa\x0cx7<'
    str_1 = '4cTO+z"n]rI7p'
    var_0 = module_0.inspect_package(str_0, str_1, str_0, str_1)
    module_0.inspect_package(var_0, list_0, var_0, var_0)


@pytest.mark.xfail(strict=True)
def test_case_36():
    set_0 = set()
    str_0 = "!D"
    var_0 = module_3.walk_packages()
    var_1 = var_0.__repr__()
    var_2 = var_1.__repr__()
    var_3 = var_2.__eq__(str_0)
    list_0 = [var_3]
    module_0.inspect_package(set_0, str_0, str_0, list_0)


@pytest.mark.xfail(strict=True)
def test_case_37():
    str_0 = "f^*bRR/6(k\tzl'f\"P"
    str_1 = "PlEZWu~g~&E"
    var_0 = module_0.inspect_package(str_0, str_1, str_0, str_0)
    var_1 = var_0.__eq__(str_1)
    str_2 = "hzlz70/.z_H"
    none_type_0 = None
    str_3 = "a0GKb#(I-]t\tg9|OvqBU"
    module_0.inspect_package(none_type_0, str_3, str_2, var_1)


@pytest.mark.xfail(strict=True)
def test_case_38():
    bool_0 = False
    str_0 = ""
    str_1 = "s#!9b6+8n\x0bkq],m"
    none_type_0 = None
    var_0 = module_3.walk_packages(prefix=none_type_0)
    list_0 = [var_0, var_0]
    var_1 = module_2.inspect_module(bool_0, str_1, bool_0, list_0)
    list_1 = [var_1, var_1, var_1, var_1]
    module_0.inspect_package(bool_0, str_0, bool_0, list_1)


@pytest.mark.xfail(strict=True)
def test_case_39():
    str_0 = ""
    str_1 = "_fields"
    str_2 = ": it needs to be imported explicitly."
    none_type_0 = None
    var_0 = module_0.inspect_package(str_2, str_1, none_type_0, str_0)
    var_1 = var_0.__eq__(str_2)
    module_0.inspect_package(str_0, str_1, var_0, var_0)


@pytest.mark.xfail(strict=True)
def test_case_40():
    str_0 = ""
    str_1 = "\n    Given a module and a partially namespaced type name, returns a tuple of information about the type:\n    - the full-namespaced type name, to draw relationships between types without ambiguity\n    - the short type name, for display purposes\n\n    Different approaches are combined to derive the type information:\n    - when the partially namespaced type is found during AST parsing (class constructors)\n    - when the partially namespaced type is found during class inspection (dataclasses, class static variables, named tuples, enums)\n\n    The two approaches are a bit entangled for now, they could be separated a bit more for performance sake.\n    "
    bool_0 = False
    module_0.inspect_package(str_0, str_1, str_0, bool_0)


@pytest.mark.xfail(strict=True)
def test_case_41():
    list_0 = []
    str_0 = '\nk[0#"NgDa\x0cx7<'
    str_1 = '4cTO+z"n]rI7p'
    var_0 = module_0.inspect_package(str_0, str_1, str_0, str_1)
    module_0.inspect_package(var_0, list_0, var_0, var_0)


@pytest.mark.xfail(strict=True)
def test_case_42():
    set_0 = set()
    str_0 = "!D"
    var_0 = module_3.walk_packages()
    var_1 = var_0.__repr__()
    var_2 = var_1.__repr__()
    var_3 = var_2.__eq__(str_0)
    list_0 = [var_3]
    module_0.inspect_package(set_0, str_0, str_0, list_0)


@pytest.mark.xfail(strict=True)
def test_case_43():
    str_0 = "f^*bRR/6(k\tzl'f\"P"
    str_1 = "PlEZWu~g~&E"
    var_0 = module_0.inspect_package(str_0, str_1, str_0, str_0)
    var_1 = var_0.__eq__(str_1)
    str_2 = "hzlz70/.z_H"
    none_type_0 = None
    str_3 = "a0GKb#(I-]t\tg9|OvqBU"
    module_0.inspect_package(none_type_0, str_3, str_2, var_1)


@pytest.mark.xfail(strict=True)
def test_case_44():
    bool_0 = False
    str_0 = ""
    str_1 = "s#!9b6+8n\x0bkq],m"
    none_type_0 = None
    var_0 = module_3.walk_packages(prefix=none_type_0)
    list_0 = [var_0, var_0]
    var_1 = module_2.inspect_module(bool_0, str_1, bool_0, list_0)
    list_1 = [var_1, var_1, var_1, var_1]
    module_0.inspect_package(bool_0, str_0, bool_0, list_1)

@pytest.mark.xfail(strict=True)
def test_case_45():
    str_0 = ""
    str_1 = "_fields"
    str_2 = ": it needs to be imported explicitly."
    none_type_0 = None
    var_0 = module_0.inspect_package(str_2, str_1, none_type_0, str_0)
    var_1 = var_0.__eq__(str_2)
    module_0.inspect_package(str_0, str_1, var_0, var_0)


@pytest.mark.xfail(strict=True)
def test_case_46():
    str_0 = ""
    str_1 = "\n    Given a module and a partially namespaced type name, returns a tuple of information about the type:\n    - the full-namespaced type name, to draw relationships between types without ambiguity\n    - the short type name, for display purposes\n\n    Different approaches are combined to derive the type information:\n    - when the partially namespaced type is found during AST parsing (class constructors)\n    - when the partially namespaced type is found during class inspection (dataclasses, class static variables, named tuples, enums)\n\n    The two approaches are a bit entangled for now, they could be separated a bit more for performance sake.\n    "
    bool_0 = False
    module_0.inspect_package(str_0, str_1, str_0, bool_0)


@pytest.mark.xfail(strict=True)
def test_case_47():
    list_0 = []
    str_0 = '\nk[0#"NgDa\x0cx7<'
    str_1 = '4cTO+z"n]rI7p'
    var_0 = module_0.inspect_package(str_0, str_1, str_0, str_1)
    module_0.inspect_package(var_0, list_0, var_0, var_0)


@pytest.mark.xfail(strict=True)
def test_case_48():
    set_0 = set()
    str_0 = "!D"
    var_0 = module_3.walk_packages()
    var_1 = var_0.__repr__()
    var_2 = var_1.__repr__()
    var_3 = var_2.__eq__(str_0)
    list_0 = [var_3]
    module_0.inspect_package(set_0, str_0, str_0, list_0)


@pytest.mark.xfail(strict=True)
def test_case_49():
    str_0 = "f^*bRR/6(k\tzl'f\"P"
    str_1 = "PlEZWu~g~&E"
    var_0 = module_0.inspect_package(str_0, str_1, str_0, str_0)
    var_1 = var_0.__eq__(str_1)
    str_2 = "hzlz70/.z_H"
    none_type_0 = None
    str_3 = "a0GKb#(I-]t\tg9|OvqBU"
    module_0.inspect_package(none_type_0, str_3, str_2, var_1)

@pytest.mark.xfail(strict=True)
def test_case_50():
    bool_0 = False
    str_0 = ""
    str_1 = "s#!9b6+8n\x0bkq],m"
    none_type_0 = None
    var_0 = module_3.walk_packages(prefix=none_type_0)
    list_0 = [var_0, var_0]
    var_1 = module_2.inspect_module(bool_0, str_1, bool_0, list_0)
    list_1 = [var_1, var_1, var_1, var_1]
    module_0.inspect_package(bool_0, str_0, bool_0, list_1)
