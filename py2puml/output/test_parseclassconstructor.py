# Test cases automatically generated by Pynguin (https://github.com/se2p/pynguin).
# Please check them before you use them.
import pytest
import builtins as module_0
import inspect as module_1
import ast as module_2
import parseclassconstructor as module_3
import py2puml.parsing.astvisitors as module_4
import py2puml.parsing.moduleresolver as module_5
import py2puml.domain.umlclass as module_6
import py2puml.domain.umlrelation as module_7


@pytest.mark.xfail(strict=True)
def test_case_0():
    type_0 = module_0.bool
    var_0 = module_1.unwrap(type_0, stop=type_0)
    var_0.generic_visit(type_0)


def test_case_1():
    none_type_0 = None
    type_0 = module_2.expr
    str_0 = "Hn9B"
    tuple_0 = module_3.parse_class_constructor(type_0, type_0, str_0)
    type_1 = module_0.int
    str_1 = "A)H>9OB';VZP!SMPIK2"
    tuple_1 = module_3.parse_class_constructor(none_type_0, type_1, str_1)
    str_2 = "\x0b"
    tuple_2 = module_3.parse_class_constructor(type_1, type_1, str_2)
    type_2 = module_4.Variable
    str_3 = "QZ\na7m}d$?I&["
    tuple_3 = module_3.parse_class_constructor(type_2, str_3, str_3)
    str_4 = "FJe&"
    tuple_4 = module_3.parse_class_constructor(type_2, tuple_3, str_3)
    str_5 = ""
    str_6 = "w$hZ57%d A"
    tuple_5 = module_3.parse_class_constructor(str_2, str_6, str_3)
    tuple_6 = module_3.parse_class_constructor(tuple_4, str_5, str_6)
    str_7 = "py2puml/py2puml.domain.puml"
    str_8 = "\\TsO:-59K5M"
    tuple_7 = module_3.parse_class_constructor(tuple_6, none_type_0, str_8)
    tuple_8 = module_3.parse_class_constructor(none_type_0, str_4, str_7)
    str_9 = ".\\1"
    tuple_9 = module_3.parse_class_constructor(type_1, str_9, none_type_0)
    str_10 = " lines"
    tuple_10 = module_3.parse_class_constructor(type_2, str_4, str_10)
    tuple_11 = module_3.parse_class_constructor(type_2, none_type_0, str_4)
    type_3 = module_2.AST
    module_resolver_0 = module_5.ModuleResolver(str_2)
    tuple_12 = module_3.parse_class_constructor(type_3, module_resolver_0, str_10)
    str_11 = "\n!2X="
    tuple_13 = module_3.parse_class_constructor(none_type_0, str_11, none_type_0)
    tuple_14 = module_3.parse_class_constructor(tuple_8, str_5, str_8)
    type_4 = module_2.AST
    tuple_15 = module_3.parse_class_constructor(type_4, none_type_0, tuple_6)
    tuple_16 = module_3.parse_class_constructor(none_type_0, none_type_0, str_11)
    tuple_17 = module_3.parse_class_constructor(str_4, tuple_16, tuple_13)
    int_0 = 0
    tuple_18 = module_3.parse_class_constructor(none_type_0, type_2, int_0)


@pytest.mark.xfail(strict=True)
def test_case_2():
    bool_0 = False
    set_0 = {bool_0}
    str_0 = "=q\r(3vBhK"
    tuple_0 = module_3.parse_class_constructor(set_0, str_0, str_0)
    str_1 = "py2puml/py2puml.domain.puml"
    none_type_0 = None
    uml_attribute_0 = module_6.UmlAttribute(str_1, none_type_0, none_type_0)
    var_0 = uml_attribute_0.__repr__()
    var_0.visit_FunctionDef(none_type_0)


@pytest.mark.xfail(strict=True)
def test_case_3():
    type_0 = module_2.FunctionDef
    type_1 = module_0.set
    type_2 = module_2.expr
    tuple_0 = module_3.parse_class_constructor(type_2, type_1, type_1)
    str_0 = "i\\+wZO3<3v!8)"
    tuple_1 = module_3.parse_class_constructor(type_1, str_0, str_0)
    none_type_0 = None
    tuple_2 = module_3.parse_class_constructor(type_0, tuple_1, none_type_0)
    none_type_1 = None
    str_1 = "bY#Q?"
    tuple_3 = module_3.parse_class_constructor(str_0, none_type_1, str_1)
    str_2 = "QD.e@w=Z\r-~U>P"
    str_3 = "FE}+.G"
    tuple_4 = module_3.parse_class_constructor(none_type_1, str_2, str_3)
    type_3 = module_7.UmlRelation
    type_4 = module_0.dict
    tuple_5 = module_3.parse_class_constructor(type_4, str_2, none_type_1)
    str_4 = ".L_Zj`t4wtd=("
    module_3.parse_class_constructor(type_3, type_3, str_4)


def test_case_4():
    type_0 = module_2.NodeVisitor
    str_0 = "v`}B]7Mp0mrvp*"
    tuple_0 = module_3.parse_class_constructor(type_0, str_0, str_0)


def test_case_5():
    str_0 = ")e]*+3\x0cPw\nN\r&Gra/."
    tuple_0 = module_3.parse_class_constructor(str_0, str_0, str_0)
    tuple_1 = (str_0, str_0)
    str_1 = "v"
    type_0 = module_4.ConstructorVisitor
    str_2 = "Any"
    tuple_2 = module_3.parse_class_constructor(type_0, str_0, str_2)
    tuple_3 = module_3.parse_class_constructor(type_0, str_0, str_2)
    tuple_4 = module_3.parse_class_constructor(tuple_1, str_0, str_1)


def test_case_6():
    pass


@pytest.mark.xfail(strict=True)
def test_case_7():
    none_type_0 = None
    str_0 = "C["
    tuple_0 = module_3.parse_class_constructor(none_type_0, str_0, str_0)
    module_2.parse(none_type_0, none_type_0, feature_version=none_type_0)


@pytest.mark.xfail(strict=True)
def test_case_8():
    type_0 = module_2.FunctionDef
    str_0 = "U"
    tuple_0 = module_3.parse_class_constructor(type_0, type_0, str_0)
    type_1 = module_6.UmlAttribute
    str_1 = "\n    Given a module and a partially namespaced type name, returns a tuple of information about the type:\n    - the full-namespaced type name, to draw relationships between types without ambiguity\n    - the short type name, for display purposes\n\n    Different approaches are combined to derive the type information:\n    - when the partially namespaced type is found during AST parsing (class constructors)\n    - when the partially namespaced type is found during class inspection (dataclasses, class static variables, named tuples, enums)\n\n    The two approaches are a bit entangled for now, they could be separated a bit more for performance sake.\n    "
    module_3.parse_class_constructor(type_1, str_1, type_0)


@pytest.mark.xfail(strict=True)
def test_case_9():
    none_type_0 = None
    str_0 = ".__init__"
    tuple_0 = module_3.parse_class_constructor(none_type_0, str_0, str_0)
    type_0 = module_5.NamespacedType
    type_1 = module_2.NodeVisitor
    tuple_1 = module_3.parse_class_constructor(type_1, type_0, type_1)
    complex_0 = 416.166719 - 1045.0272j
    type_2 = module_6.UmlAttribute
    module_3.parse_class_constructor(type_2, complex_0, complex_0)
